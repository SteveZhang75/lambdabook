# 传统系统的问题 {#1}

```
   传统的应用大部分都是居于关系型数据库的，特别是关键的交易系统，有着严格的事务要求和交易结果的可靠性存储，因此在实现上大都选择大厂商的关系DB。关系DB用来CRUD的交易管理是合适的，但是随着交易后处理数据量的增大，数据管理系统（DBMS）和数仓系统（DW）就会显得不适应了。这些交易后处理包括报表生成，BI分析，风控管理等等系统为了适应客户的新需求，往往都要从交易系统再导一遍数据，由于系统设计的惯性，多数还是选择关系型DB，但是由于报表数据处理层次越来越深，变换越来越复杂，实时性要求越来越高，导致系统越来越复杂，很多系统做着做着就到了崩溃的边缘，到了增加硬件解决不了的地步，因此急需一种新的架构来适用这种变化，大数据领域的架构和设计可以引入进传统领域来解决新问题。
```

# Lambda架构的背景

大数据处理技术需要解决这种可伸缩性与复杂性。  
首先要认识到这种分布式的本质，要很好地处理分区与复制，不会导致错误分区引起查询失败，而是要将这些逻辑内化到数据库中。当需要扩展系统时，可以非常方便地增加节点，系统也能够针对新节点进行rebalance。  
其次是要让数据成为不可变的。原始数据永远都不能被修改，这样即使犯了错误，写了错误数据，原来好的数据并不会受到破坏。

Storm的作者Nathan Marz提出的一个实时大数据处理框架（Lambda架构）就满足以上两点。Marz在Twitter工作期间开发了著名的实时大数据处理框架Storm，Lambda架构是其根据多年进行分布式大数据系统的经验总结提炼而成。

Lambda架构的目标是设计出一个能满足实时大数据系统关键特性的架构，包括有：高容错、低延时和可扩展等。Lambda架构整合离线计算和实时计算，融合不可变性（Immunability），读写分离和复杂性隔离等一系列架构原则，可集成Hadoop，Kafka，Storm，Spark，Hbase等各类大数据组件。

以下引用网上关于大数据的一些关键特性，以及数据输入处理和存储的高度概括，从本质上讲，这类系统很适合用来实现交易后处理系统

# 大数据系统的关键特性 {#3}

Marz介绍Big Data System许具备的属性：

a、Robust and fault-tolerant（容错性和鲁棒性）：对大规模分布式系统来说，机器是不可靠的，可能会当机，但是系统需要是健壮、行为正确的，即使是遇到机器错误。除了机器错误，人更可能会犯错误。在软件开发中难免会有一些Bug，系统必须对有Bug的程序写入的错误数据有足够的适应能力，所以比机器容错性更加重要的容错性是人为操作容错性。对于大规模的分布式系统来说，人和机器的错误每天都可能会发生，如何应对人和机器的错误，让系统能够从错误中快速恢复尤其重要。

b、Low latency reads and updates（低延时）：很多应用对于读和写操作的延时要求非常高，要求对更新和查询的响应是低延时的。

c、Scalable（横向扩容）：当数据量/负载增大时，可扩展性的系统通过增加更多的机器资源来维持性能。也就是常说的系统需要线性可扩展，通常采用scale out（通过增加机器的个数）而不是scale up（通过增强机器的性能）。

d、General（通用性）：系统需要能够适应广泛的应用，包括金融领域、社交网络、电子商务数据分析等。

e、Extensible（可扩展）：需要增加新功能、新特性时，可扩展的系统能以最小的开发代价来增加新功能。

f、Allows ad hoc queries（方便查询）：数据中蕴含有价值，需要能够方便、快速的查询出所需要的数据。

d、Minimal maintenance（易于维护）：系统要想做到易于维护，其关键是控制其复杂性，越是复杂的系统越容易出错、越难维护。

h、Debuggable（易调试）：当出问题时，系统需要有足够的信息来调试错误，找到问题的根源。其关键是能够追根溯源到每个数据生成点。

# 数据系统的本质 {#4}

Marz认为：数据系统通过查询过去的（部分、全部）数据去回答问题。如：他是一个什么样的人？他有多少朋友？这个账号是否收支平衡？。因此，DataSystem的通用定义为：  
Query＝Function（alldata）。  
对通用的表达式进行分解得到：  
数据系统＝数据＋查询  
从而可以从数据和查询两个方面认识大数据系统的本质。

## 数据本本质：When&What {#5}

数据是一个不可分割的单元，数据有两个关键的特性：When和What。

_**When**_是只数据是与时间相关的，也就是数据是在某个时间产生的。这个非常重要，在具有事务特性的数据库中，操作的先后顺序对结果至关重要。例如数据库的Binlog日志。因此，数据的时间性质决定了数据的全局发生先后，也就决定了数据的结果。

_**What**_是只数据的本身。由于数据跟某个时间点相关，所以数据的本身是不可变的\(immutable\)，过往的数据已经成为事实（Fact），你不可能回到过去的某个时间点去改变数据事实。这也就意味着对数据的操作其实只有两种：读取已存在的数据和添加更多的新数据。采用数据库的记法，CRUD就变成了CR，Update和Delete本质上其实是新产生的数据信息，用C来记录。

## 数据的存储：Store Everything Rawly and Immutably {#6}

根据上述对数据特性的分析，lambda架构中对数据的存储采用的方式是：数据不可变，存储所有数据。

采用这两种方式存储的好处：

a、简单。采用不可变的数据模型，存储数据时只需要简单的往主数据集后追加数据即可。相比于采用可变的数据模型，为了Update操作，数据通常需要被索引，从而能快速找到要更新的数据去做更新操作。

b、应对人为和机器的错误。人和机器每天都可能会出错，如何应对人和机器的错误，让数据系统快速恢复极其重要。不可变和可重复计算是应对认为和机器错误的常用方法。采用可变数据模型，引发错误的数据有可能被覆盖而丢失。相比于采用不可变的数据模型，因为所有的数据都在，引发错误的数据也在。修复的方法就可以简单的是遍历数据集上存储的所有的数据，丢弃错误的数据，重新计算得到Views。重新计算的关键点在于利用数据的时间特性决定的全局次序，依次顺序重新执行，必然能得到正确的结果。

当前业界有很多采用不可变数据模型来存储所有数据的例子。比如分布式数据库Datomic，基于不可变数据模型来存储数据，从而简化了设计。分布式消息中间件Kafka，基于Log日志，以追加append-only的方式来存储消息。

# Lambda架构 {#7}

Lambda架构的主要思想是将大数据系统架构为多层个层次，分别为批处理层（batchlayer）、实时处理层（speedlayer）、服务层（servinglayer）如图（C）。

理想状态下，任何数据访问都可以从表达式Query = function\(all data\)开始，但是，若数据达到相当大的一个级别（例如PB），且还需要支持实时查询时，就需要耗费非常庞大的资源。一个解决方式是预运算查询函数（precomputed query funciton）。书中将这种预运算查询函数称之为Batch View（A），这样当需要执行查询时，可以从Batch View中读取结果。这样一个预先运算好的View是可以建立索引的，因而可以支持随机读取（B）。于是系统就变成：  
（A）batch view = function\(all data\)；  
（B）query = function\(batch view\)。

### lambda 架构

![](/assets/import.png)

## BatchLayer {#8}

在Lambda架构中，实现（A）batch view = function\(all data\)的部分称之为BatchLayer。他承担两个职责：

a、存储Master Dataset，这是一个不变的持续增长的数据集

b、针对这个Master Dataset进行预运算

在全体数据集上在线运行查询函数得到结果的代价太大，同时处理查询时间过长，导致用户体验不好。如果我们预先在数据集上计算并保存预计算的结果，查询的时候直接返回预计算的结果，而无需重新进行复制耗时的计算。显然，batchview是一个批处理过程，如采用Hadoop或spark支持的map－reduce方式。采用这种方式计算得到的每个view都支持再次计算，且每次计算的结果都相同。

![](http://img1.tbcdn.cn/L1/461/1/ae6085b9b96ce476c3b567cfe8ff79feaffd06bc)

_**对View的理解：**_

View是一个和业务关联性比较大的概念，View的创建需要从业务自身的需求出发。一个通用的数据库查询系统，查询对应的函数千变万化，不可能穷举。但是如果从业务自身的需求出发，可以发现业务所需要的查询常常是有限的。Batch Layer需要做的一件重要的工作就是根据业务的需求，考察可能需要的各种查询，根据查询定义其在数据集上对应的Views。这些预查询的结果可以用NoSQL DB存储起来。

## SpeedLayer {#9}

BatchLayer能够很好的处理离线数据，但是在很多场景数据不断产生，并且业务场景需要实时查询。SpeedLayer就是设计用来处理增量实时数据。

SpeedLayer和BatchLayer比较类似，对数据进行计算并生成RealtimeView，其主要的区别在于：

a、SpeedLayer处理的数据是最近的增量数据流，BatchLayer处理的是全体数据集

b、SpeedLayer为了效率，接收到新数据及时更新RealtimeView，而BatchLayer根据全体离线数据直接得到BatchView。SpeedLayer是一种增量计算，而非重新计算（recomputation）。

c、SpeedLayer因为采用增量计算，所以延迟小，而BatchLayer是全数据集的计算，耗时比较长。

综上所诉，SpeedLayer是BatchLayer在实时性上的一个补充。如图（F）

![](http://img4.tbcdn.cn/L1/461/1/801023eb29ec075ccd56f7528605d78f830231ad)  
图（F）

## ServingLayer {#10}

BatchLayer通过对MasterDataset执行查询获得BatchView，Speed Layer通过增量计算提供RealtimeView。Lambda架构的ServingLayer用于响应用户的查询请求，合并Batch View和Realtime View中的结果数据集到最终的数据集，如图（G）。因此，ServingLayer的职责包含：

a、对batchView和RealTimeView的随机访问

b、更新BatchVeiw和RealTimeView，并负责结合两者的数据，对用户提供统一的接口

![](http://img3.tbcdn.cn/L1/461/1/4e55b0d83cb428c5b34847fd2574527100268169)  
图（G）

综上所诉，ServingLayer采用如下等式（D）表示：Query＝function（BatchViews，RealtimeView）。

# lambda 组件的选择



![](/assets/lambdaComponent.png)



